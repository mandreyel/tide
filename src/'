#include "bencode.hpp"
#include "view.hpp"

#include <algorithm>
#include <cassert>
#include <cstdint>

/**
 * This is a simple RAII wrapper intended to replace raw buffer building when a
 * std::vector is unsuitable. Releases memory upon destruction and dynamically increases
 * the buffer size if adding an element would make it exceed its capacity.
 * When the buffer is deemed complete, call release(), which hands over ownership to the
 * caller and no longer manages the buffer, i.e., doesn't free the memory in the dtor.
 */
template<
    typename T
> class buffer_builder
{
    T* m_buffer = nullptr;
    size_t m_capacity = 0;
    size_t m_size = 0;

public:

    buffer_builder() = default;

    explicit buffer_builder(const int capacity) : m_capacity(capacity)
    {
        m_buffer = new T[m_capacity];
    }

    ~buffer_builder()
    {
        if(m_buffer)
        {
            delete[] m_buffer;
        }
        m_buffer = nullptr;
        m_capacity = m_size = 0;
    }

    int size() const noexcept
    {
        return m_size;
    }

    bool is_empty() const noexcept
    {
        return size() == 0;
    }

    T& front() noexcept
    {
        assert(m_size > 0);
        return m_buffer[0];
    }

    T& back() noexcept
    {
        assert(m_size > 0);
        return m_buffer[m_size - 1];
    }

    T* data()
    {
        return m_buffer;
    }

    void reserve(const int n)
    {
        if(n <= m_capacity)
        {
            return;
        }

        T* new_buffer = new T[n];
        assert(new_buffer);
        if(m_buffer)
        {
            std::copy(m_buffer, m_buffer + m_size, new_buffer);
            delete[] m_buffer;
        }
        m_buffer = new_buffer;
    }

    void push(T t)
    {
        if(m_size >= m_capacity)
        {
            grow_buffer();
        }
        m_buffer[m_size++] = std::move(t);
    }

    template<typename... Args>
    void emplace(Args&&... args)
    {
        if(m_size >= m_capacity)
        {
            grow_buffer();
        }
        m_buffer[m_size++] = T(std::forward<Args>(args)...);
    }

    view<T> release()
    {
        view<T> view(m_buffer, m_size);
        m_buffer = nullptr;
        m_capacity = m_size = 0;
        return view;
    }

    T& operator[](const int i)
    {
        assert(i < m_size);
        return m_buffer[i];
    }

private:

    void grow_buffer()
    {
        // TODO use realloc
        const size_t new_capacity = m_capacity == 0 ? 8
                                                    : 2 * m_capacity;
        reserve(new_capacity);
    }
};

class bcontainer_decoder;

/*
struct bpod_decoder
{
    std::unique_ptr<belement> decode(std::string& source)
    {
        switch(source[m_pos])
        {
        case '0': case '1': case '2': case '3': case '4':
        case '5': case '6': case '7': case '8': case '9':
            return decode_bstring();
        case 'i':
            return decode_bnumber();
        default:
            return bcontainer_decoder(std::move(source)).decode();
            //throw std::runtime_error("bencode error TODO");
        }
    }

private:

    // These functions are only called if m_encoded[m_pos] corresponds to their
    // respective types, i.e. no extra error handling is necessary.

    std::unique_ptr<belement> decode_bstring()
    {
        // check for correct string length
        if((m_encoded[m_pos] == '0') && (m_encoded[m_pos + 1] != ':'))
        {
            // TODO error
        }
        const int colon_index = m_encoded.find(':', m_pos);
        const int length = std::atoi(m_encoded.c_str() + m_pos);

        // go to the beginning of the actual string
        m_pos = colon_index + 1;

        std::string s = m_encoded.substr(m_pos, length);

        // go to the next element
        m_pos += length;

        return std::make_unique<bstring>(std::move(s));
    }

    std::unique_ptr<belement> decode_bnumber()
    {
        // go past the 'i' identifier
        ++m_pos;

        // don't allow leading zeros
        if((m_encoded[m_pos] == '0') && (m_encoded[m_pos + 1] != 'e'))
        {
            // TODO error
        }

        const int end = m_encoded.find('e', m_pos);
        const int64_t num = std::atol(m_encoded.c_str() + m_pos);

        // got to the next element
        m_pos = end + 1;
        return std::make_shared<bnumber>(value);
    }
};
*/

class bcontainer_decoder
{
    // Temporary holds the list of tokens, ownership of which will be passed to the
    // decoded belement object.
    buffer_builder<btoken> m_tokens;

    // This is the raw bencoded string. Ownership of this string will be handed over to
    // the belement instance produced after decoding.
    std::string m_encoded;

    // The index of the current character in m_encoded.
    int m_pos = 0;

public:

    explicit bcontainer_decoder(std::string s) : m_encoded(std::move(s)) {}

    bmap decode_map()
    {
        if(m_encoded.empty() || (m_encoded.front() != 'd') || (m_encoded.back() != 'e'))
        {
            throw std::runtime_error("decode_map: bencoding error TODO");
        }
        m_tokens.reserve(count_tokens());
        decode_bmap();
        view<btoken> view(m_tokens.release());
        return bmap(const_view<btoken>(view.data(), view.size()), std::move(m_encoded));
    }

    blist decode_list()
    {
        if(m_encoded.empty() || (m_encoded.front() != 'l') || (m_encoded.back() != 'e'))
        {
            throw std::runtime_error("decode_list: bencoding error TODO");
        }
        m_tokens.reserve(count_tokens());
        decode_blist();
        view<btoken> view(m_tokens.release()); // TODO
        return blist(const_view<btoken>(view.data(), view.size()), std::move(m_encoded));
    }

    std::unique_ptr<belement> decode()
    {
        if(m_encoded.front() == 'd')
        {
            return std::make_unique<bmap>(decode_map());
        }
        else if(m_encoded.front() == 'l')
        {
            return std::make_unique<blist>(decode_list());
        }
        return nullptr;
    }

private:

    /**
     * Goes over m_encoded and counts the number of btokens that would be constructed by
     * parsing the entire input string. This is to allocate the tokens buffer in one
     * instead of incrementally.
     */
    int count_tokens()
    {
        int count = 0;
        for(auto i = 0; i < m_encoded.length() - 1; ++i)
        {
            switch(m_encoded[i])
            {
            case '0': case '1': case '2': case '3': case '4':
            case '5': case '6': case '7': case '8': case '9':
            {
                const int str_length = std::atoi(&m_encoded[i]);
                while((m_encoded[i] != ':') && (i < m_encoded.length()))
                {
                    ++i;
                }
                if(i == m_encoded.length())
                {
                    throw std::runtime_error("count_tokens: bencode error TODO");
                }
                i += str_length;
                break;
            }
            case 'i':
            {
                while((m_encoded[i] != 'e') && (i < m_encoded.length()))
                {
                    ++i;
                }
                break;
            }}
            ++count;
        }
        std::cerr << "num tokens: " << count << '\n';
        return count;
    }

    /**
     * Dispatches decoding to specialized functions and returns the number of tokens
     * that were created decoding the current element.
     */
    int decode_dispatch()
    {
        assert(m_pos < m_encoded.length());
        const int prev_num_tokens = m_tokens.size();
        //std::cout << "type: " << m_encoded[m_pos] << '\n';
        switch(m_encoded[m_pos])
        {
        case '0': case '1': case '2': case '3': case '4':
        case '5': case '6': case '7': case '8': case '9':
            decode_bstring();
            return 1;
        case 'i':
            decode_bnumber();
            return 1;
        case 'l':
            decode_blist();
            return m_tokens.size() - prev_num_tokens;
        case 'd':
            decode_bmap();
            return m_tokens.size() - prev_num_tokens;
        case 'e':
            assert(false);
        default:
            throw std::runtime_error("cannot bdecode, unknown type" + m_encoded[m_pos]);
        }
    }

    void decode_bstring()
    {
        // check for correct string length
        if((m_encoded[m_pos] == '0') && (m_encoded[m_pos + 1] != ':'))
        {
            throw std::runtime_error("decode_string: bencoding error TODO");
        }

        const int colon_index = m_encoded.find(':', m_pos);
        std::cerr << "\tcolon_index: " << colon_index << '\n';

        btoken bstring;
        bstring.type = btype::string;
        bstring.offset = m_pos;
        bstring.length = colon_index - m_pos + 1;
        // if this is not the last element, the offset is always 1 (default is 0)
        if(m_pos < m_encoded.length() - 1)
        {
            bstring.next_item_array_offset = 1;
        }
        std::cerr << "\toffset: " << bstring.offset << '\n';
        std::cerr << "\tlength: " << bstring.length << '\n';
        m_tokens.push(std::move(bstring));

        // go to the next element
        const int str_length = std::atoi(&m_encoded[m_pos]);
        std::cerr << "\tstr_length: " << str_length << '\n';
        m_pos = colon_index + 1 + str_length;
        std::cerr << "\tm_pos: " << m_pos << '\n'<< '\n';
    }

    void decode_bnumber()
    {
        // don't allow leading zeros
        if((m_encoded[m_pos] == '0') && (m_encoded[m_pos + 1] != 'e'))
        {
            throw std::runtime_error("decode_number: bencoding error TODO");
        }

        const int end = m_encoded.find('e', m_pos);
        std::cerr << "\tint 'e' pos: " << end << '\n';

        btoken bnumber;
        bnumber.type = btype::number;
        bnumber.offset = m_pos;
        bnumber.length = end - m_pos + 1;
        // if this is not the last element, the offset is always 1 (default is 0)
        if(m_pos < m_encoded.length() - 1)
        {
            bnumber.next_item_array_offset = 1;
        }

        std::cerr << "\tint offset: " << bnumber.offset << '\n';
        std::cerr << "\tint length: " << bnumber.length << '\n';
        m_tokens.push(std::move(bnumber));
        // got to the next element
        m_pos = end + 1;
        std::cerr << "\tm_pos: " << m_pos << '\n'<< '\n';
    }

    void decode_blist()
    {
        {
            btoken list_header;
            list_header.type = btype::list;
            list_header.next_item_array_offset = 1;
            m_tokens.push(std::move(list_header));
        }
        // obtain a reference to the list token as we'll need it later (the one above
        // is moved into m_tokens so don't use that)
        btoken& list_header = m_tokens.back();

        // go to first element in list
        ++m_pos;
        while((m_pos < m_encoded.length() - 1) && (m_encoded[m_pos] != 'e'))
        {
            // add the number of tokens that were parsed while decoding value; this is
            // necessary to determine where the list ends
            list_header.next_item_array_offset += decode_dispatch();
            ++list_header.length;
        }

        std::cerr << "list offset: " << list_header.offset << '\n';
        std::cerr << "list next_item_array_offset: " << list_header.next_item_array_offset << '\n';
        std::cerr << "list length: " << list_header.length << '\n';
        std::cerr << "len(tokens): " << m_tokens.size() << '\n';
    }

    void decode_bmap()
    {
        {
            btoken map_header;
            map_header.type = btype::map;
            map_header.next_item_array_offset = 1;
        }
        m_tokens.push(std::move(map_header));
        // obtain a reference to the map token as we'll need it later (the one above
        // is moved into m_tokens so don't use that)
        btoken& map_header = m_tokens.back();
        std::cerr << "map next_item_array_offset: " << map_header.next_item_array_offset << '\n';

        // go to first element in map
        ++m_pos;
        while((m_pos < m_encoded.length() - 1) && (m_encoded[m_pos] != 'e'))
        {
            switch(m_encoded[m_pos])
            {
            case '0': case '1': case '2': case '3': case '4':
            case '5': case '6': case '7': case '8': case '9':
                // key is a string, go on
                break;
            default:
                throw std::runtime_error("decode_bmap: bencoding error TODO");
            }

            // decode key
            decode_bstring();
            std::cerr << "\tmap next_item_array_offset: " << map_header.next_item_array_offset << '\n';
            ++map_header.next_item_array_offset;
            std::cerr << "\tmap next_item_array_offset: " << map_header.next_item_array_offset << '\n';
            // TODO validate key

            // decode value and add the number of tokens that were parsed while decoding
            // value to array offset accumulator
            // this is necessary to determine where the map ends
            map_header.next_item_array_offset += decode_dispatch();
            // a map's length is its number of key-value pairs
            ++map_header.length;
            std::cerr << "\tmap next_item_array_offset: " << map_header.next_item_array_offset << '\n';
            std::cerr << "\tmap length: " << map_header.length << '\n';
            std::cerr << '\n';
        }

        std::cerr << "map offset: " << map_header.offset << '\n';
        std::cerr << "map next_item_array_offset: " << map_header.next_item_array_offset << '\n';
        std::cerr << "map length: " << map_header.length << '\n';
        std::cerr << "len(tokens): " << m_tokens.size() << '\n';
    }
};

bmap decode_bmap(std::string s)
{
    return bcontainer_decoder(std::move(s)).decode_map();
}

blist decode_blist(std::string s)
{
    return bcontainer_decoder(std::move(s)).decode_list();
}
